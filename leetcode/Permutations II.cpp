//先对数组进行排序，这样在DFS的时候，可以先判断前面的一个数是否和自己相等，//相等的时候则前面的数必须使用了，自己才能使用，这样就不会产生重复的排列了    class Solution {    public:        int n;        int visit[100];        vector<vector<int> > result;        vector<int> numm;        void recur(vector<int> t,int cnt){            if(cnt==n){                result.push_back(t);                return;            }            for(int i=0;i<n;i++){                if((i==0&&visit[i]==0)||(visit[i]==0&&numm[i-1]==numm[i]&&visit[i-1]==1)||(visit[i]==0&&numm[i]!=numm[i-1])){                    visit[i]=1;                    t.push_back(numm[i]);                    recur(t,cnt+1);                    t.pop_back();                    visit[i]=0;                }            }            return;        }        vector<vector<int> > permuteUnique(vector<int> &num) {            n=num.size();            result.clear();            numm=num;            sort(numm.begin(),numm.end());            if(n==0)                return result;            memset(visit,0,sizeof(visit));            vector<int> v;            recur(v,0);            return result;        }    };